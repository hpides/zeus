{{! 
  hash used: {
    pipelineId: string,
    tupleLength: int,
    keyType: string, // How do we support multiple keys? Object could do the trick with a custom key exctractor
    nativeKeyType: string, // same as keyType except lowercased, except for Object2Object
    keyOffset: int
    aggImplementation: String,
    shouldCountPerWindow: Bool
  }
}}
package de.hpi.des.hdes.engine.temp;

import java.nio.ByteBuffer;

import de.hpi.des.hdes.engine.execution.Dispatcher;
import de.hpi.des.hdes.engine.execution.buffer.ReadBuffer;
import de.hpi.des.hdes.engine.execution.Stoppable;
import it.unimi.dsi.fastutil.longs.*;
import it.unimi.dsi.fastutil.ints.*;

public class {{{pipelineId}}} implements Runnable, Stoppable {
    final private long windowSlide = {{{windowLength}}};
    final private long windowLength = {{{windowLength}}};
    private long earliestOpenWindow = Long.MAX_VALUE;
    private long latestTimestamp = 0;
    final private ReadBuffer input;
    final private Dispatcher dispatcher;

    private final byte[] output = new byte[{{{outputEventLength}}}*{{{vectorSize}}}];
    private final ByteBuffer outputBuffer = ByteBuffer.wrap(output);
    private int outputCounter = 0;

    final private Long2{{aggregationValueType.uppercaseName}}OpenHashMap windowToState = new Long2{{aggregationValueType.uppercaseName}}OpenHashMap();
    
    private final int[] freeableOffsets = new int[{{{vectorSize}}}];
    private int freeableIndex = 0;

    {{{#shouldCountPerWindow}}}
    final private Long2IntOpenHashMap windowToCount = new Long2IntOpenHashMap();
    {{{/shouldCountPerWindow}}}

    private boolean shutdownFlag = false;

    {{#interfaces}}
    {{> InterfaceDefinition.java.mustache}}
    {{/interfaces}}

    public {{{pipelineId}}} (final ReadBuffer input, final Dispatcher dispatcher) {
        this.input = input;
        this.dispatcher = dispatcher;
    }

    private void readEvent() {
        input.mark();
        final long eventTimestamp = input.getBuffer().getLong();
        if (eventTimestamp < latestTimestamp) {
            input.reset();
            freeInput(input.getBuffer().position());
            input.getBuffer().position(input.getBuffer().position()+8+{{tupleLength}}+1);
            return;
        }
        final long windowStart = eventTimestamp - (eventTimestamp % windowLength);
        if (earliestOpenWindow > windowStart) {
            earliestOpenWindow = windowStart;
        }
        
        {{#variables}}
        {{> VariableDefiniton.java.mustache}}
        {{/variables}}

        {{{operators}}}

        final {{aggregationValueType.lowercaseName}} state = this.windowToState.computeIfAbsent(windowStart, w -> 0);

        {{{#shouldCountPerWindow}}}
        final int count = this.windowToCount.computeIfAbsent(windowStart, w -> 0);
        {{{/shouldCountPerWindow}}}

        final {{aggregationValueType.lowercaseName}} current = {{{aggregationVariable}}};
        final {{aggregationValueType.lowercaseName}} newState = {{{aggregateImplementation}}};

        this.windowToState.put(windowStart, newState);

        {{{#shouldCountPerWindow}}}
        this.windowToCount.put(windowStart, count + 1);
        {{{/shouldCountPerWindow}}}

        if (input.getBuffer().get() == (byte) 1) {
            latestTimestamp = Math.max(latestTimestamp, eventTimestamp);
            for (; earliestOpenWindow + windowLength <= latestTimestamp && earliestOpenWindow
                    + windowLength <= latestTimestamp; earliestOpenWindow += windowSlide) {
                trigger(earliestOpenWindow);
            }
        }
        input.reset();
        freeInput(input.getBuffer().position());
    }

    private void trigger(long eventTimestamp) {
        this.outputCounter++;
        {{aggregationValueType.lowercaseName}} value = windowToState.remove(eventTimestamp);
        outputBuffer.putLong(0, eventTimestamp).put{{aggregationValueType.uppercaseName}}(8, value).put(8 + {{aggregationValueType.length}}, (byte) 0);
        if(this.outputCounter == {{{vectorSize}}}) {
            while (!dispatcher.write("{{pipelineId}}", output) && !shutdownFlag);
            this.outputCounter = 0;
        }
    }

    private void freeInput(int offset) {
        freeableOffsets[freeableIndex] = offset;
        freeableIndex++;
        if(freeableIndex == {{{vectorSize}}}) {
            dispatcher.free(input, freeableOffsets);
            freeableIndex = 0;
        }
    }

    @Override
    public void run() {
        while (!Thread.interrupted() && !shutdownFlag) {
            if (input.getBuffer().position() == input.getBuffer().capacity()) {
                dispatcher.resetReadLimit("{{pipelineId}}", input);
            }
            for (int remainingBytes=Math.min(input.remainingBytes(), {{{readVectorSize}}}*({{{inputEventLength}}})); remainingBytes > 0; remainingBytes -= ({{{inputEventLength}}})) {
                readEvent();
            }
        }
    }

    @Override
    public void shutdown() {
        shutdownFlag = true;
    }
}
