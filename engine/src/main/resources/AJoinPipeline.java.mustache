{{! 
  hash used: {
    pipelineId: string,
    leftTupleLength: int,
    rightTupleLength: int,
    keyType: string, // How do we support multiple keys? Object could do the trick with a custom key exctractor
    nativeKeyType: string, same as keyType except lowercased, except for Object2Object
    leftKeyOffset: int
    rightKeyOffset: int
  }
}}
package de.hpi.des.hdes.engine.temp;

import java.nio.ByteBuffer;

import it.unimi.dsi.fastutil.*;

public class {{{pipelineId}}} {
    final private long windowSlide;
    final private long windowLength;
    private long earliestOpenWindowJoin = Long.MAX_VALUE;
    private long latestTimestampLeft;
    private long latestTimestampRight;
    final private int leftTupleLength = {{leftTupleLength}};
    final private int rightTupleLength = {{rightTuplLength}};
    final private int leftKeyOffset = {{leftKeyOffset}};
    final private int rightKeyOffset = {{rightKeyOffset}};
    final private ByteBuffer leftInput;
    final private ByteBuffer rightInput;
    final private ByteBuffer output;
    final private Long2ObjectMap<{{keyType}}2ObjectOpenHashMap<IntSet>> leftWindowsToBuckets = new Long2ObjectOpenHashMap<>();
    final private Long2ObjectMap<{{keyType}}2ObjectOpenHashMap<IntSet>> rightWindowsToBuckets = new Long2ObjectOpenHashMap<>();

    public {{{pipelineId}}} (final ByteBuffer left, final ByteBuffer right, final Dispatcher dispatcher, final long windowLength,
            final long windowSlide) {
        leftInput = left;
        rightInput = right;
        this.dispatcher = dispatcher;
        this.windowLength = windowLength;
        this.windowSlide = windowSlide;
    }

    public void readEventLeft(int offset) {
        leftInput.position(offset);
        final long eventTimestamp = leftInput.getLong();
        leftInput.mark();
        if (eventTimestamp < latestTimestampLeft) {
            return;
        }
        final long windowStart = eventTimestamp - (eventTimestamp % windowLength);
        if (earliestOpenWindowJoin > windowStart) {
            earliestOpenWindowJoin = windowStart;
        }

        {{keyType}}2ObjectOpenHashMap<IntSet> bucket = leftWindowsToBuckets.computeIfAbsent(windowStart,
                w -> new {{keyType}}2ObjectOpenHashMap<IntSet>());
        leftInput.position(leftInput)
        IntSet set = bucket.computeIfAbsent(leftInput.get{{keyType}}(), w -> new IntArraySet());
        leftInput.reset();
        set.add(leftInput.position());
        leftInput.position(leftInput.position() + leftTupleLength);

        if (leftInput.getChar() == (char) 1) {
            latestTimestampLeft = Math.max(latestTimestampLeft, eventTimestamp);
            for (; earliestOpenWindowJoin + windowLength <= latestTimestampLeft && earliestOpenWindowJoin
                    + windowLength <= latestTimestampRight; earliestOpenWindowJoin += windowSlide) {
                trigger(earliestOpenWindowJoin);
            }
        }
        leftInput.rewind();
    }

    public void readEventRight(int offset) {
        rightInput.position(offset);
        final long eventTimestamp = rightInput.getLong();
        rightInput.mark();
        if (eventTimestamp < latestTimestampRight) {
            return;
        }
        final long windowStart = eventTimestamp - (eventTimestamp % windowLength);
        if (earliestOpenWindowJoin > windowStart) {
            earliestOpenWindowJoin = windowStart;
        }

        {{keyType}}2ObjectOpenHashMap<IntSet> bucket = rightWindowsToBuckets.computeIfAbsent(windowStart,
                w -> new {{keyType}}2ObjectOpenHashMap<IntSet>());
        IntSet set = bucket.computeIfAbsent(rightInput.get{{keyType}}(), w -> new IntArraySet());
        rightInput.reset();
        // Custom offset needed for key?s
        rightInput.rewind();
    }

    private void trigger(final long timeStamp) {
        {{keyType}}2ObjectOpenHashMap<IntSet> leftBucket = leftWindowsToBuckets.get(timeStamp);
        {{keyType}}2ObjectOpenHashMap<IntSet> rightBucket = rightWindowsToBuckets.get(timeStamp);
        for ({{nativeKeyType}} key : leftBucket.keySet()) {
            if (rightBucket.containsKey(key)) {
                for (int leftOffset : leftBucket.get(key)) {
                    for (int rightOffset : rightBucket.get(key)) {
