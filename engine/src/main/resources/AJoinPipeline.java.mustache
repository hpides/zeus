{{! 
  hash used: {
    pipelineId: string,
    leftTupleLength: int,
    rightTupleLength: int,
    keyType: string, // How do we support multiple keys? Object could do the trick with a custom key exctractor
    nativeKeyType: string, same as keyType except lowercased, except for Object2Object
    leftKeyOffset: int
    rightKeyOffset: int,
    leftImplementation: String,
    rightImplementation: String,
  }
}}
package de.hpi.des.hdes.engine.temp;

import java.nio.ByteBuffer;

import it.unimi.dsi.fastutil.*;

public class {{{pipelineId}}} {
    final private long windowSlide;
    final private long windowLength;
    private long earliestOpenWindowJoin = Long.MAX_VALUE;
    private long latestTimestampLeft;
    private long latestTimestampRight;
    final private int leftTupleLength = {{leftTupleLength}};
    final private int rightTupleLength = {{rightTuplLength}};
    final private int leftKeyOffset = {{leftKeyOffset}};
    final private int rightKeyOffset = {{rightKeyOffset}};
    final private ByteBuffer leftInput;
    final private ByteBuffer rightInput;
    final private ByteBuffer output;
    final private Long2ObjectMap<{{keyType}}2ObjectOpenHashMap<IntSet>> leftWindowsToBuckets = new Long2ObjectOpenHashMap<>();
    final private Long2ObjectMap<{{keyType}}2ObjectOpenHashMap<IntSet>> rightWindowsToBuckets = new Long2ObjectOpenHashMap<>();

    public {{{pipelineId}}} (final ByteBuffer left, final ByteBuffer right, final Dispatcher dispatcher, final long windowLength,
            final long windowSlide) {
        leftInput = left;
        rightInput = right;
        this.dispatcher = dispatcher;
        this.windowLength = windowLength;
        this.windowSlide = windowSlide;
    }

    public void readEventLeft() {
        leftInput.position(offset);
        final long eventTimestamp = leftInput.getLong();
        leftInput.mark();
        if (eventTimestamp < latestTimestampLeft) {
            return;
        }
        final long windowStart = eventTimestamp - (eventTimestamp % windowLength);
        if (earliestOpenWindowJoin > windowStart) {
            earliestOpenWindowJoin = windowStart;
        }

        {{keyType}}2ObjectOpenHashMap<IntSet> bucket = leftWindowsToBuckets.computeIfAbsent(windowStart,
                w -> new {{keyType}}2ObjectOpenHashMap<IntSet>());
        leftInput.position(leftInput.position()+leftKeyOffset);
        IntSet set = bucket.computeIfAbsent(leftInput.get{{keyType}}(), w -> new {{keyType}}ArraySet());
        leftInput.reset();
        set.add(leftInput.position());
        leftInput.position(leftInput.position() + leftTupleLength);

        if (leftInput.getChar() == (char) 1) {
            latestTimestampLeft = Math.max(latestTimestampLeft, eventTimestamp);
            for (; earliestOpenWindowJoin + windowLength <= latestTimestampLeft && earliestOpenWindowJoin
                    + windowLength <= latestTimestampRight; earliestOpenWindowJoin += windowSlide) {
                trigger(earliestOpenWindowJoin);
            }
        }
    }

    public void readEventRight() {
        rightInput.position(offset);
        final long eventTimestamp = rightInput.getLong();
        rightInput.mark();
        if (eventTimestamp < latestTimestampRight) {
            return;
        }
        final long windowStart = eventTimestamp - (eventTimestamp % windowLength);
        if (earliestOpenWindowJoin > windowStart) {
            earliestOpenWindowJoin = windowStart;
        }

        {{keyType}}2ObjectOpenHashMap<IntSet> bucket = rightWindowsToBuckets.computeIfAbsent(windowStart,
                w -> new {{keyType}}2ObjectOpenHashMap<IntSet>());
        rightInput.position(rightInput.position() + rightKeyOffset);
        IntSet set = bucket.computeIfAbsent(rightInput.get{{keyType}}(), w -> new {{keyType}}ArraySet());
        rightInput.reset();
        set.add(rightInput.position());
        rightInput.position(rightInput.position() + rightTupleLength);

        if (rightInput.getChar() == (char) 1) {
            latestTimestampRight = Math.max(latestTimestampRight, eventTimestamp);
            for (; earliestOpenWindowJoin + windowLength <= latestTimestampLeft && earliestOpenWindowJoin
                    + windowLength <= latestTimestampRight; earliestOpenWindowJoin += windowSlide) {
                trigger(earliestOpenWindowJoin);
            }
        }
    }

    private void trigger(final long timeStamp) {
        {{keyType}}2ObjectOpenHashMap<IntSet> leftBucket = leftWindowsToBuckets.get(timeStamp);
        {{keyType}}2ObjectOpenHashMap<IntSet> rightBucket = rightWindowsToBuckets.get(timeStamp);
        int maxLeftOffset = 0;
        int maxRightOffset = 0;
        for ({{nativeKeyType}} key : leftBucket.keySet()) {
            if (rightBucket.containsKey(key)) {
                for (int leftOffset : leftBucket.get(key)) {
                    for (int rightOffset : rightBucket.get(key)) {
                        this.writeOutput(leftOffset, rightOffset);
                        maxLeftOffset = Math.max(leftOffset, maxLeftOffset);
                        maxRightOffset = Math.max(rightOffset, maxRightOffset);
                    }
                }
                ;
            }
        }
        dispatcher.free(leftInput, maxLeftOffset);
        dispatcher.free(rightInput, maxRightOffset);
    }

    public void writeOutput(int leftOffset, int rightOffset) {
        leftInput.position(leftOffset);
        rightInput.position(rightOffset);
        byte[] out = new byte[8 + 2 + leftTupleLength + rightTupleLength];
        ByteBuffer b = ByteBuffer.wrap(out).putLong(count++);
        leftInput.get(out, 8, leftTupleLength);
        rightInput.get(out, 8 + leftTupleLength, rightTupleLength);
        b.putChar(8 + leftTupleLength + rightTupleLength, (char) 0);
        while (!dispatcher.write(this, out));
        leftInput.clear();
        rightInput.clear();
    }

    @Override
    public void run() {
        while (true) {
            if (leftInput.hasRemaining())
                readEventLeft();
            if (rightInput.hasRemaining())
                readEventRight();
            if (leftInput.position() == leftInput.capacity()) {
                dispatcher.resetLimit(leftInput);
            }
            if (rightInput.position() == rightInput.capacity()) {
                dispatcher.resetLimit(rightInput);
            }
        }
    }
}
