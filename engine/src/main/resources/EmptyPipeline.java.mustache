package de.hpi.des.hdes.engine.temp;

import de.hpi.des.hdes.engine.execution.Dispatcher;
import de.hpi.des.hdes.engine.execution.buffer.ReadBuffer;
import de.hpi.des.hdes.engine.execution.Stoppable;

import java.nio.ByteBuffer;

public class {{{className}}} implements Runnable, Stoppable {
  private final ReadBuffer input;
  private boolean shutdownFlag = false;
  {{#hasChild}}
  private final Dispatcher dispatcher;
  private final byte[] output = new byte[{{{outputEventLength}}}];
  private final ByteBuffer outputBuffer = ByteBuffer.wrap(output);
  {{/hasChild}}

  {{#interfaces}}
  {{> InterfaceDefinition.java.mustache}}
  {{/interfaces}}
  
  public {{{className}}}(final ReadBuffer input{{#hasChild}}, final Dispatcher dispatcher{{/hasChild}}) {
    this.input = input;
    {{#hasChild}}
    this.dispatcher = dispatcher;
    {{/hasChild}}
  }

  public void readEvent(){
    input.mark();
    int nextPosition = input.getBuffer().position() + {{inputEventLength}};
    {{#variables}}
    {{> VariableDefiniton.java.mustache}}
    {{/variables}}
    {{{implementation}}}
    input.getBuffer().position(nextPosition);
  }

  @Override
    public void run() {
        while (!Thread.interrupted() && !shutdownFlag) {
            if (input.getBuffer().position() == input.getBuffer().capacity()) {
                dispatcher.resetReadLimit(input);
            }
            if (input.hasRemaining()) {
                readEvent();
            }
        }
    }

    @Override
    public void shutdown() {
        shutdownFlag = true;
    }
}
