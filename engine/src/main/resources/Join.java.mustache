import java.util.HashMap;

import com.google.common.collect.ArrayListMultimap;
import com.google.common.collect.Multimap;

public class {{{className}}} {

    private final HashMap<Long, Multimap<Integer, Integer>> stateLeft;
    private final HashMap<Long, Multimap<Integer, Integer>> stateRight;
    private final HashMap<Long, Integer> windowToState;
    private final long length = {{{length}}};
    private final long slide = {{{slide}}};

    private long earliestOpenWindowJoin = Long.MAX_VALUE;
    private long earliestOpenWindowAggregation = Long.MAX_VALUE;
    private long latestTimestampLeft;
    private long latestTimestampRight;

    public {{{className}}}() {
        this.stateLeft = new HashMap<>();
        this.stateRight = new HashMap<>();
        this.windowToState = new HashMap<>();
        this.collector = collector;
        this.latestTimestampLeft = 0;
        this.latestTimestampRight = 0;
    }

    public void joinLeftPipeline(final AData<> event) {
        final long timestamp = event.getEventTime();
        final int key = event.getValue();
        final int value = event.getValue();
        latestTimestampLeft = timestamp;
        long windowStart = timestamp - (timestamp % length);
        if (earliestOpenWindowJoin > windowStart) {
            earliestOpenWindowJoin = windowStart;
        }

        if (key % 3 == 0) {
            for (; windowStart <= timestamp; windowStart += slide) {
                final Multimap<Integer, Integer> state = this.stateLeft.computeIfAbsent(windowStart,
                        w -> ArrayListMultimap.create());
                state.put(key, value);
                this.stateLeft.put(windowStart, state);
                Multimap<Integer, Integer> rightState = stateRight.get(windowStart);
                if (rightState != null && rightState.containsKey(key)) {
                    for (Integer rightValue : rightState.get(key)) {
                        aggregatePipeline(windowStart, value, rightValue);
                    }
                }
            }
        }

        for (; earliestOpenWindowJoin + length <= latestTimestampLeft
                && earliestOpenWindowJoin + length <= latestTimestampRight; earliestOpenWindowJoin += slide) {
            if (stateLeft.containsKey(earliestOpenWindowJoin)) {
                stateLeft.remove(earliestOpenWindowJoin);
            }
            if (stateRight.containsKey(earliestOpenWindowJoin)) {
                stateRight.remove(earliestOpenWindowJoin);
            }
        }
    }

    public void joinRightPipeline(final long timestamp, final int key, final int value) {
        latestTimestampRight = timestamp;
        long windowStart = timestamp - (timestamp % length);
        if (earliestOpenWindowJoin > windowStart) {
            earliestOpenWindowJoin = windowStart;
        }

        if (key % 4 == 0) {
            for (; windowStart <= timestamp; windowStart += slide) {
                final Multimap<Integer, Integer> state = this.stateRight.computeIfAbsent(windowStart,
                        w -> ArrayListMultimap.create());
                state.put(key, value);
                this.stateRight.put(windowStart, state);
                Multimap<Integer, Integer> leftState = stateLeft.get(windowStart);
                if (leftState != null && leftState.containsKey(key)) {
                    for (Integer leftValue : leftState.get(key)) {
                        aggregatePipeline(windowStart, leftValue, value);
                    }
                }
            }
        }

        for (; earliestOpenWindowJoin + length <= latestTimestampLeft
                && earliestOpenWindowJoin + length <= latestTimestampRight; earliestOpenWindowJoin += slide) {
            if (stateLeft.containsKey(earliestOpenWindowJoin)) {
                stateLeft.remove(earliestOpenWindowJoin);
            }
            if (stateRight.containsKey(earliestOpenWindowJoin)) {
                stateRight.remove(earliestOpenWindowJoin);
            }
        }
    }

    public void aggregatePipeline(final long timestamp, final int valueLeft, final int valueRight) {
        if (earliestOpenWindowAggregation > timestamp) {
            earliestOpenWindowAggregation = timestamp;
        }
        final Integer state = this.windowToState.computeIfAbsent(timestamp, w -> 0);
        this.windowToState.put(timestamp, (state + valueLeft + valueRight));
        for (; earliestOpenWindowAggregation + length <= timestamp; earliestOpenWindowAggregation += slide) {
            if (windowToState.containsKey(earliestOpenWindowAggregation)) {
                collector.collect(this.windowToState.get(earliestOpenWindowAggregation));
                this.windowToState.remove(earliestOpenWindowAggregation);
            }
        }
    }

}
