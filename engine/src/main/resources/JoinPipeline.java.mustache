{{! 
  hash used: {
    pipelineId: string,
    leftTupleLength: int,
    rightTupleLength: int,
    keyType: string, // How do we support multiple keys? Object could do the trick with a custom key exctractor
    nativeKeyType: string, // same as keyType except lowercased, except for Object2Object
    leftKeyOffset: int
    rightKeyOffset: int,
    leftImplementation: String,
    rightImplementation: String,
  }
}}
package de.hpi.des.hdes.engine.temp;

import java.nio.ByteBuffer;

import de.hpi.des.hdes.engine.execution.Dispatcher;
import de.hpi.des.hdes.engine.execution.buffer.ReadBuffer;
import de.hpi.des.hdes.engine.execution.Stoppable;

import it.unimi.dsi.fastutil.longs.*;
import it.unimi.dsi.fastutil.ints.*;

public class {{{pipelineId}}} implements Runnable, Stoppable {
    final private long windowSlide = {{{windowLength}}};
    final private long windowLength = {{{windowLength}}};
    private long earliestOpenWindowJoin = Long.MAX_VALUE;
    private long latestTimestampLeft = 0;
    private long latestTimestampRight = 0;
    final private ReadBuffer leftInput;
    final private ReadBuffer rightInput;
    final private Dispatcher dispatcher;
    final byte[] out = new byte[8 + {{{leftTupleLength}}} + {{{rightTupleLength}}} + 1];
    
    final private Long2ObjectOpenHashMap<{{keyType}}2ObjectOpenHashMap<IntSet>> leftWindows = new Long2ObjectOpenHashMap<>();
    final private Long2ObjectOpenHashMap<{{keyType}}2ObjectOpenHashMap<IntSet>> rightWindows = new Long2ObjectOpenHashMap<>();

    private boolean shutdownFlag = false;

    public {{{pipelineId}}} (final ReadBuffer left, final ReadBuffer right, final Dispatcher dispatcher) {
        leftInput = left;
        rightInput = right;
        this.dispatcher = dispatcher;
        this.windowLength = windowLength;
        this.windowSlide = windowSlide;
    }

    public void readEventLeft() {
        leftInput.mark();
        final long eventTimestamp = leftInput.getBuffer().getLong();
        if (eventTimestamp < latestTimestampLeft) {
            leftInput.reset();
            dispatcher.free(leftInput, leftInput.getBuffer().position());
            leftInput.getBuffer().position(leftInput.getBuffer().position()+8+{{leftTupleLength}}+1);
            return;
        }
        final long windowStart = eventTimestamp - (eventTimestamp % windowLength);
        if (earliestOpenWindowJoin > windowStart) {
            earliestOpenWindowJoin = windowStart;
        }

        {{{leftImplementation}}}

        {{keyType}}2ObjectOpenHashMap<IntSet> leftWindow = leftWindows.computeIfAbsent(windowStart,
                w -> new {{keyType}}2ObjectOpenHashMap<IntSet>());
        leftInput.getBuffer().position(leftInput.getBuffer().position()+{{leftKeyOffset}});
        {{nativeKeyType}} key = leftInput.getBuffer().get{{keyType}}();
        IntSet offsets = leftWindow.computeIfAbsent(key, w -> new {{keyType}}ArraySet());
        leftInput.reset();
        offsets.add(leftInput.getBuffer().position());
        
        {{keyType}}2ObjectOpenHashMap<IntSet> rightWindow = rightWindows.getOrDefault(windowStart, null);
        if(rightWindow != null && rightWindow.containsKey(key)){
            for ({{nativeKeyType}} rightOffset : rightWindow.get(key)) {
                writeOutput(leftInput.getBuffer().position(), rightOffset);
            }
        }

        leftInput.getBuffer().position(leftInput.getBuffer().position() + 8 + {{leftTupleLength}});

        if (leftInput.getBuffer().get() == (byte) 1) {
            latestTimestampLeft = Math.max(latestTimestampLeft, eventTimestamp);
            for (; earliestOpenWindowJoin + windowLength <= latestTimestampLeft && earliestOpenWindowJoin
                    + windowLength <= latestTimestampRight; earliestOpenWindowJoin += windowSlide) {
                trigger(earliestOpenWindowJoin);
            }
        }
    }

    public void readEventRight() {
        rightInput.mark();
        final long eventTimestamp = rightInput.getBuffer().getLong();
        if (eventTimestamp < latestTimestampRight) {
            rightInput.reset();
            dispatcher.free(rightInput, rightInput.getBuffer().position());
            rightInput.getBuffer().position(rightInput.getBuffer().position()+8+{{rightTupleLength}}+1);
            return;
        }
        final long windowStart = eventTimestamp - (eventTimestamp % windowLength);
        if (earliestOpenWindowJoin > windowStart) {
            earliestOpenWindowJoin = windowStart;
        }

        {{{rightImplementation}}}

        {{keyType}}2ObjectOpenHashMap<IntSet> rightWindow = rightWindows.computeIfAbsent(windowStart,
                w -> new {{keyType}}2ObjectOpenHashMap<IntSet>());
        rightInput.getBuffer().position(rightInput.getBuffer().position()+{{rightKeyOffset}});
        {{nativeKeyType}} key = rightInput.getBuffer().get{{keyType}}();
        IntSet offsets = rightWindow.computeIfAbsent(key, w -> new {{keyType}}ArraySet());
        rightInput.reset();
        offsets.add(rightInput.getBuffer().position());
        
        {{keyType}}2ObjectOpenHashMap<IntSet> leftWindow = leftWindows.getOrDefault(windowStart, null);
        if(leftWindow != null && leftWindow.containsKey(key)){
            for ({{nativeKeyType}} leftOffset : leftWindow.get(key)) {
                writeOutput(leftOffset, rightInput.getBuffer().position());
            }   
        }

        rightInput.getBuffer().position(rightInput.getBuffer().position() + 8 + {{rightTupleLength}});        

        if (rightInput.getBuffer().get() == (byte) 1) {
            latestTimestampRight = Math.max(latestTimestampRight, eventTimestamp);
            for (; earliestOpenWindowJoin + windowLength <= latestTimestampLeft && earliestOpenWindowJoin
                    + windowLength <= latestTimestampRight; earliestOpenWindowJoin += windowSlide) {
                trigger(earliestOpenWindowJoin);
            }
        }
    }

    private void trigger(final long timestamp) {
        {{keyType}}2ObjectOpenHashMap<IntSet> leftWindow = rightWindows.remove(timestamp);
        {{keyType}}2ObjectOpenHashMap<IntSet> rightWindow = leftWindows.remove(timestamp);
        if (leftWindow != null) {
            for ({{nativeKeyType}} key : leftWindow.keySet()) {
                for (int leftOffset : leftWindow.get(key)) {
                    dispatcher.free(leftInput, leftOffset);
                }
            }
        }
        if (rightWindow != null) {
            for ({{nativeKeyType}} key : rightWindow.keySet()) {
                for (int rightOffset : rightWindow.get(key)) {
                    dispatcher.free(rightInput, rightOffset);
                }
            }
        }
    }

    public void writeOutput(int leftOffset, int rightOffset) {
        leftInput.getBuffer().position(leftOffset);
        rightInput.getBuffer().position(rightOffset);
        ByteBuffer b = ByteBuffer.wrap(out).putLong(0,((long)(leftInput.getBuffer().getLong(leftOffset)+rightInput.getBuffer().getLong(rightOffset))/2));
        leftInput.getBuffer().get(out, 8, {{leftTupleLength}});
        rightInput.getBuffer().get(out, 8 + {{leftTupleLength}}, {{rightTupleLength}});
        b.put(8 + {{leftTupleLength}} + {{rightTupleLength}}, (byte) 0);
        while (!dispatcher.write("{{pipelineId}}", out) && !shutdownFlag); 
    }

    @Override
    public void run() {
        while (!Thread.interrupted() && !shutdownFlag) {
            if (leftInput.getBuffer().position() == leftInput.getBuffer().capacity()) {
                dispatcher.resetReadLimit(leftInput);
            }
            if (rightInput.getBuffer().position() == rightInput.getBuffer().capacity()) {
                dispatcher.resetReadLimit(rightInput);
            }
            if (leftInput.hasRemaining()) {
                readEventLeft();
            }
            if (rightInput.hasRemaining()) {
                readEventRight();
            }
        }
    }

    @Override
    public void shutdown() {
        shutdownFlag = true;
    }
}